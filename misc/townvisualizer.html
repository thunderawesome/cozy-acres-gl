<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cozy Town - Visualizer</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üè°</text></svg>">
    <style>
        :root {
            --primary-color: #4CAF50;
            --primary-hover: #45a049;
            --bg-dark: #1a1a1a;
            --panel-bg: #2a2a2a;
            --input-bg: #333;
            --border-color: #444;
            --text-main: #f0f0f0;
            --text-dim: #ccc;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: var(--bg-dark);
            color: var(--text-main);
            padding: 20px;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 24px;
            font-weight: 300;
            letter-spacing: -0.5px;
        }

        .main-layout {
            display: flex;
            gap: 24px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }

        .controls-panel {
            background: var(--panel-bg);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            width: 320px;
            flex-shrink: 0;
        }

        .control-section {
            margin-bottom: 18px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
        }

        .control-section:last-of-type {
            border-bottom: none;
            margin-bottom: 10px;
        }

        .section-header {
            color: var(--primary-color);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 12px;
            font-weight: 800;
            opacity: 0.9;
        }

        .input-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        label {
            font-size: 0.85rem;
            color: var(--text-dim);
        }

        input[type="number"] {
            background: var(--input-bg);
            border: 1px solid #555;
            color: white;
            padding: 5px 8px;
            border-radius: 6px;
            width: 70px;
            text-align: right;
            transition: border-color 0.2s;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        input[type="range"] {
            width: 100%;
            accent-color: var(--primary-color);
            cursor: pointer;
        }

        .button-stack {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }

        button {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-hover);
            transform: translateY(-1px);
        }

        .btn-debug {
            background: #8b8b00;
            color: white;
        }

        .btn-debug:hover {
            background: #a5a500;
        }

        .btn-secondary {
            background: #444;
            color: white;
            flex: 1;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #555;
        }

        .btn-secondary:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        #canvas-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        canvas {
            background: #000;
            border: 3px solid var(--border-color);
            border-radius: 4px;
            image-rendering: pixelated;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.6);
        }

        .info-panel {
            background: #111;
            padding: 12px;
            border-radius: 6px;
            font-family: 'Cascadia Code', 'Courier New', monospace;
            font-size: 0.8rem;
            border-left: 3px solid var(--primary-color);
            min-height: 1.2em;
        }

        .legend {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            background: var(--panel-bg);
            padding: 12px;
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        .swatch {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>

<body>

    <h1>Cozy Town Generator</h1>

    <div class="main-layout">
        <div class="controls-panel">
            <div class="control-section">
                <div class="section-header">World Settings</div>
                <div class="input-group">
                    <label>Seed</label>
                    <input type="text" id="seed" value="12345" oninput="this.value = this.value.replace(/[^0-9]/g, '')">
                </div>
                <div class="input-group">
                    <label>Width (Acres)</label>
                    <input type="number" id="width" value="5" min="2" max="15" step="1">
                </div>
                <div class="input-group">
                    <label>Height (Acres)</label>
                    <input type="number" id="height" value="6" min="2" max="15" step="1">
                </div>
            </div>

            <div class="control-section">
                <div class="section-header">Cliffs</div>
                <div class="input-group">
                    <label>Min Plateau Row</label>
                    <input type="number" id="minPlateauRow" value="1" min="0" max="10">
                </div>
                <div class="input-group">
                    <label>Max Plateau Row</label>
                    <input type="number" id="maxPlateauRow" value="3" min="0" max="10">
                </div>
                <div class="input-group">
                    <label>High Chance (0-1)</label>
                    <input type="number" id="highPlateauChance" value="0.75" step="0.05" min="0" max="1">
                </div>
            </div>

            <div class="control-section">
                <div class="section-header">Rivers</div>
                <div class="input-group">
                    <label>Width</label>
                    <input type="number" id="riverWidth" value="3" min="1" max="10">
                </div>
                <div class="input-group">
                    <label>Meander %</label>
                    <input type="number" id="riverMeanderChance" value="50" min="0" max="100">
                </div>
                <div class="input-group">
                    <label>Horizontal %</label>
                    <input type="number" id="riverHorizontalChance" value="50" min="0" max="100">
                </div>
            </div>

            <div class="control-section">
                <div class="section-header">Visualization</div>
                <div class="input-group">
                    <label>Tile Size</label>
                    <input type="number" id="tileSize" min="2" max="12" value="6" oninput="render()">
                </div>
                <div class="input-group">
                    <label>Speed</label>
                    <input type="range" id="animSpeed" min="0" max="200" value="150" oninput="runLoop()">
                </div>
            </div>

            <div class="section-header">Actions</div>
            <div class="button-stack">
                <button class="btn-primary" onclick="generateInstant()">‚ö° Instant Generate</button>
                <button class="btn-primary" onclick="randomSeed()" style="background: #5c6bc0;">üé≤ Shuffle Seed</button>
                <button class="btn-debug" onclick="startDebug()">üêõ Debug / Animate</button>

                <div style="display:flex; gap:8px;">
                    <button class="btn-secondary" id="btnPause" onclick="togglePause()" disabled>Pause</button>
                    <button class="btn-secondary" id="btnStep" onclick="step()" disabled>Step</button>
                </div>
            </div>

            <div class="control-section">
                <div class="input-group" style="margin-bottom: 4px;">
                    <label>Timeline</label>
                    <span id="stepDisplay"
                        style="font-family: monospace; font-size: 0.8rem; color: var(--primary-color);">0</span>
                </div>
                <input type="range" id="timeline" value="0" disabled oninput="scrub(this.value)">
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="canvas"></canvas>

            <div class="legend">
                <div class="legend-item">
                    <div class="swatch" style="background:rgb(76,153,51)"></div> Grass L0
                </div>
                <div class="legend-item">
                    <div class="swatch" style="background:rgb(114,191,76)"></div> Grass L1
                </div>
                <div class="legend-item">
                    <div class="swatch" style="background:rgb(153,229,102)"></div> Grass L2
                </div>
                <div class="legend-item">
                    <div class="swatch" style="background:rgb(127,115,102)"></div> Cliff
                </div>
                <div class="legend-item">
                    <div class="swatch" style="background:rgb(220,198,158)"></div> Beach
                </div>
                <div class="legend-item">
                    <div class="swatch" style="background:rgb(25,102,204)"></div> Ocean
                </div>
                <div class="legend-item">
                    <div class="swatch" style="background:#4FC3F7"></div> River
                </div>
                <div class="legend-item">
                    <div class="swatch" style="background:#00BCD4"></div> Pond
                </div>
                <div class="legend-item">
                    <div class="swatch" style="background:#A1887F"></div> Ramp
                </div>
            </div>

            <div class="info-panel" id="debugInfo">Ready.</div>
        </div>
    </div>

    <script>
        // ‚îÄ‚îÄ RNG: Mersenne Twister 64-bit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        class MT19937_64 {
            constructor(seed) {
                this.n = 312n;
                this.m = 156n;
                this.a = 0xB5026F5AA96619E9n;
                this.state = new BigUint64Array(Number(this.n));
                this.index = this.n;

                this.state[0] = BigInt(seed);
                for (let i = 1n; i < this.n; i++) {
                    this.state[Number(i)] = (6364136223846793005n * (this.state[Number(i - 1n)] ^ (this.state[Number(i - 1n)] >> 62n)) + i);
                }
            }

            nextRaw() {
                if (this.index >= this.n) { this._twist(); }
                let x = this.state[Number(this.index++)];
                x ^= (x >> 29n) & 0x5555555555555555n;
                x ^= (x << 17n) & 0x71D67FFFEDA60000n;
                x ^= (x << 37n) & 0xFFF7EEE000000000n;
                x ^= (x >> 43n);
                return x;
            }

            next() {
                const x = this.nextRaw();
                return Number(x) / 18446744073709551616;
            }

            nextFloat(min, max) {
                return min + this.next() * (max - min);
            }

            _twist() {
                const upperMask = 0xFFFFFFFF80000000n;
                const lowerMask = 0x7FFFFFFFn;
                for (let i = 0n; i < this.n; i++) {
                    let x = (this.state[Number(i)] & upperMask) +
                        (this.state[Number((i + 1n) % this.n)] & lowerMask);
                    let xA = x >> 1n;
                    if (x % 2n !== 0n) { xA ^= this.a; }
                    this.state[Number(i)] = this.state[Number((i + this.m) % this.n)] ^ xA;
                }
                this.index = 0n;
            }
        }

        // ‚îÄ‚îÄ Constants & Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const ACRE_SIZE = 16;
        const CLIFF_CONNECTION_POINT = 12;
        const RIVER_CONNECTION_POINT = 3;  // TownConfig::RIVER_CONNECTION_POINT_OFFSET

        const TileType = {
            GRASS: 0,
            SAND: 1,
            OCEAN: 2,
            RIVER: 3,
            RIVER_MOUTH: 4,
            CLIFF: 5,
            RAMP: 6,
            POND: 7
        };

        const randomInt = (mt, min, max) => {
            const range = BigInt(max - min + 1);
            if (range <= 0n) return min;
            const raw = mt.nextRaw();
            return Number(raw % range) + min;
        };

        // ‚îÄ‚îÄ Utils (WorldGenUtils.cpp) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const Utils = {
            isAnyWater: (type) => {
                return type === TileType.RIVER ||
                    type === TileType.RIVER_MOUTH ||
                    type === TileType.OCEAN ||
                    type === TileType.POND;
            },

            createGrassTeardrop: (town, oceanAcreRow, centerX, startZ, maxWidth, depth, curveAmount, totalWidth, recorder) => {
                for (let dz = 0; dz <= depth; ++dz) {
                    let localZ = startZ + dz;
                    if (localZ < 0 || localZ >= ACRE_SIZE) continue;

                    let t = dz / depth;
                    let widthFactor = (t < 0.4) ? 1.0 : 1.0 - Math.pow((t - 0.4) / 0.6, 2);

                    let halfWidth = Math.floor(maxWidth * widthFactor);
                    let curveOffset = Math.floor(curveAmount * t * t);

                    for (let dx = -halfWidth; dx <= halfWidth; ++dx) {
                        let wx = centerX + dx + curveOffset;

                        if (wx >= 0 && wx < totalWidth) {
                            let tile = town.getTile(wx, oceanAcreRow * ACRE_SIZE + localZ);

                            if (halfWidth > 0) {
                                let dist = Math.abs(dx / (halfWidth + 0.5));
                                if (dist <= 1.0) {
                                    if (tile.type !== TileType.RIVER && tile.type !== TileType.RIVER_MOUTH) {
                                        tile.type = TileType.GRASS;
                                        if (recorder) recorder.push({ type: 'tile', x: wx, z: oceanAcreRow * ACRE_SIZE + localZ, val: TileType.GRASS, msg: 'Teardrop Grass' });
                                    }
                                    tile.elevation = 0;
                                    if (recorder) recorder.push({ type: 'elev', x: wx, z: oceanAcreRow * ACRE_SIZE + localZ, val: 0, msg: 'Teardrop Flat' });
                                }
                            }
                        }
                    }
                }
            }
        };

        // ‚îÄ‚îÄ Town Class ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        class Town {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.acres = Array.from({ length: width }, () =>
                    Array.from({ length: height }, () => ({
                        tiles: Array.from({ length: ACRE_SIZE }, () =>
                            Array.from({ length: ACRE_SIZE }, () => ({ type: TileType.GRASS, elevation: 0 }))
                        )
                    }))
                );
            }

            reset() {
                for (let ax = 0; ax < this.width; ax++) {
                    for (let ay = 0; ay < this.height; ay++) {
                        const acre = this.acres[ax][ay];
                        for (let ly = 0; ly < ACRE_SIZE; ly++) {
                            for (let lx = 0; lx < ACRE_SIZE; lx++) {
                                acre.tiles[ly][lx].type = TileType.GRASS;
                                acre.tiles[ly][lx].elevation = 0;
                            }
                        }
                    }
                }
            }

            worldToTile(wx, wz) {
                const totalW = this.width * ACRE_SIZE;
                const totalH = this.height * ACRE_SIZE;
                const x = Math.max(0, Math.min(Math.floor(wx), totalW - 1));
                const z = Math.max(0, Math.min(Math.floor(wz), totalH - 1));
                return {
                    ax: Math.floor(x / ACRE_SIZE),
                    az: Math.floor(z / ACRE_SIZE),
                    lx: x % ACRE_SIZE,
                    lz: z % ACRE_SIZE
                };
            }

            getElevation(wx, wz) {
                if (wx < 0 || wx >= this.width * ACRE_SIZE || wz < 0 || wz >= this.height * ACRE_SIZE) return -1;
                const pos = this.worldToTile(wx, wz);
                return this.acres[pos.ax][pos.az].tiles[pos.lz][pos.lx].elevation;
            }

            getTile(wx, wz) {
                const pos = this.worldToTile(wx, wz);
                return this.acres[pos.ax][pos.az].tiles[pos.lz][pos.lx];
            }

            // ‚îÄ‚îÄ 1. OCEAN GENERATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            generateOcean(rng, config, recorder) {
                const oceanRow = this.height - 1;
                const totalWidth = this.width * ACRE_SIZE;

                const phase = rng.nextFloat(0.0, 6.28318);
                const freq = rng.nextFloat(0.1, 0.2);
                const amp = randomInt(rng, 1, 3);

                const sandBoundary = new Array(totalWidth);
                for (let x = 0; x < totalWidth; x++) {
                    let wave = Math.sin(x * freq + phase) * amp;
                    sandBoundary[x] = Math.max(7, Math.min(10 + Math.round(wave), 12));
                }

                for (let ax = 0; ax < this.width; ++ax) {
                    for (let lz = 0; lz < ACRE_SIZE; ++lz) {
                        for (let lx = 0; lx < ACRE_SIZE; ++lx) {
                            let wx = ax * ACRE_SIZE + lx;
                            let wz = oceanRow * ACRE_SIZE + lz;
                            let sandStart = sandBoundary[wx];
                            let oceanStart = sandStart + 3;

                            let tile = this.getTile(wx, wz);
                            if (lz >= oceanStart) {
                                tile.type = TileType.OCEAN;
                                tile.elevation = 0;
                                if (recorder) recorder.push({ type: 'tile', x: wx, z: wz, val: TileType.OCEAN, msg: 'Ocean' });
                            } else if (lz >= sandStart) {
                                tile.type = TileType.SAND;
                                tile.elevation = 0;
                                if (recorder) recorder.push({ type: 'tile', x: wx, z: wz, val: TileType.SAND, msg: 'Sand' });
                            }
                        }
                    }
                }

                const numBlobs = 1;
                for (let i = 0; i < numBlobs; ++i) {
                    let rx = randomInt(rng, 15, totalWidth - 15);
                    let startZ = sandBoundary[rx] - 2;
                    let w = randomInt(rng, 3, 4);
                    let d = randomInt(rng, 4, 6);
                    Utils.createGrassTeardrop(this, oceanRow, rx, startZ, w, d, 1.0, totalWidth, recorder);
                }
            }

            // ‚îÄ‚îÄ 2. CLIFF GENERATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            generateCliffs(rng, config, recorder) {
                const totalWidth = this.width * ACRE_SIZE;
                const totalHeight = this.height * ACRE_SIZE;
                const connOffset = CLIFF_CONNECTION_POINT;

                const useThreeTiers = rng.next() < config.highPlateauChance;
                let minPlateauRow = config.minPlateauRow;
                if (useThreeTiers) minPlateauRow += 2;

                const midTargets = new Array(this.width);
                for (let ax = 0; ax < this.width; ax++) {
                    midTargets[ax] = (randomInt(rng, minPlateauRow, config.maxPlateauRow) + 1) * ACRE_SIZE;
                }

                const buildBoundary = (targets) => {
                    const b = new Array(totalWidth);
                    for (let x = 0; x < totalWidth; x++) {
                        const curr = Math.floor(x / ACRE_SIZE);
                        const next = Math.min(curr + 1, this.width - 1);
                        const lx = x % ACRE_SIZE;
                        b[x] = (lx <= connOffset) ? targets[curr] : targets[next];
                    }
                    return b;
                };

                const midBoundary = buildBoundary(midTargets);

                let highBoundary = new Array(totalWidth).fill(0);
                if (useThreeTiers) {
                    const highTargets = new Array(this.width);
                    for (let ax = 0; ax < this.width; ax++) {
                        let candidate = (randomInt(rng, 1, 2) + 1) * ACRE_SIZE;
                        let maxAllowed = midTargets[ax] - ACRE_SIZE;
                        highTargets[ax] = Math.max(ACRE_SIZE, Math.min(candidate, maxAllowed));
                    }
                    highBoundary = buildBoundary(highTargets);

                    for (let x = 0; x < totalWidth; ++x) {
                        let ax = Math.floor(x / ACRE_SIZE);
                        let safeMax = midTargets[ax] - ACRE_SIZE;
                        highBoundary[x] = Math.max(0, Math.min(highBoundary[x], safeMax));
                    }
                }

                for (let wx = 0; wx < totalWidth; wx++) {
                    for (let wz = 0; wz < totalHeight; wz++) {
                        let naive = 0;
                        if (wz < midBoundary[wx]) naive = 1;
                        if (useThreeTiers && wz < highBoundary[wx]) naive = 2;

                        let snapped = naive;
                        const lz = wz % ACRE_SIZE;
                        if (lz !== connOffset) {
                            const currAz = Math.floor(wz / ACRE_SIZE);
                            const targetAz = (lz < connOffset) ? currAz : currAz + 1;
                            const checkZ = targetAz * ACRE_SIZE + connOffset;
                            if (targetAz < this.height && checkZ < totalHeight) {
                                let res = 0;
                                if (checkZ < midBoundary[wx]) res = 1;
                                if (useThreeTiers && checkZ < highBoundary[wx]) res = 2;
                                snapped = res;
                            }
                        }

                        this.getTile(wx, wz).elevation = snapped;
                        if (recorder) recorder.push({ type: 'elev', x: wx, z: wz, val: snapped, msg: `Elev ${snapped}` });
                    }
                }

                for (let wx = 0; wx < totalWidth; wx++) {
                    for (let wz = 0; wz < totalHeight; wz++) {
                        const tile = this.getTile(wx, wz);
                        if (tile.elevation <= 0) continue;

                        let isCliff = false;
                        const neighbors = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                        for (const [dx, dz] of neighbors) {
                            const nx = wx + dx, nz = wz + dz;
                            if (nx < 0 || nx >= totalWidth || nz < 0 || nz >= totalHeight) continue;
                            if (this.getElevation(nx, nz) < tile.elevation) {
                                isCliff = true;
                                break;
                            }
                        }

                        if (isCliff) {
                            tile.type = TileType.CLIFF;
                            if (recorder) recorder.push({ type: 'tile', x: wx, z: wz, val: TileType.CLIFF, msg: 'Cliff Face' });
                        }
                    }
                }
            }

            // ‚îÄ‚îÄ 3. RIVER GENERATION (FIXED) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            generateRivers(rng, config, recorder) {
                const totalW = this.width * ACRE_SIZE;
                const totalH = this.height * ACRE_SIZE;
                const halfW = Math.floor(config.riverWidth / 2);

                // Matches checkPathValid in C++
                const checkPathValid = (acreZ, entryCol, exitCol) => {
                    const entryX = entryCol * ACRE_SIZE + RIVER_CONNECTION_POINT;
                    const exitX = exitCol * ACRE_SIZE + RIVER_CONNECTION_POINT;
                    const baseZ = acreZ * ACRE_SIZE;

                    let riverElev = this.getElevation(entryX, baseZ);
                    if (riverElev === -1) return false;

                    const update = (x, z) => {
                        const elev = this.getElevation(x, z);
                        // Strict check: River cannot go UP.
                        if (elev === -1 || elev > riverElev) return false;
                        // River can go DOWN (waterfall).
                        riverElev = Math.min(riverElev, elev);
                        return true;
                    };

                    // 1. Vertical segment before bend
                    for (let lz = 0; lz < RIVER_CONNECTION_POINT; ++lz) {
                        if (!update(entryX, baseZ + lz)) return false;
                    }

                    // 2. Bend point
                    if (!update(entryX, baseZ + RIVER_CONNECTION_POINT)) return false;

                    // 3. Horizontal segment (bend)
                    let dx = (exitX > entryX) ? 1 : ((exitX < entryX) ? -1 : 0);
                    let steps = Math.abs(exitX - entryX);
                    let currX = entryX;
                    for (let i = 0; i < steps; ++i) {
                        currX += dx;
                        if (!update(currX, baseZ + RIVER_CONNECTION_POINT)) return false;
                    }

                    // 4. Vertical segment after bend
                    for (let lz = RIVER_CONNECTION_POINT + 1; lz < ACRE_SIZE; ++lz) {
                        if (!update(exitX, baseZ + lz)) return false;
                    }

                    return true;
                };

                // Main River Path Generation Logic
                const colTargets = new Array(this.height);
                let currentCol = randomInt(rng, 0, this.width - 1);
                colTargets[0] = currentCol;

                let consecutiveStraight = 0;
                const maxConsecutiveStraight = 2;

                for (let az = 0; az < this.height - 1; ++az) {
                    let nextCol = currentCol;
                    let straightOk = checkPathValid(az, currentCol, currentCol);
                    let wantsMeander = (randomInt(rng, 0, 99) < config.riverMeanderChance);
                    let forceMeander = (consecutiveStraight >= maxConsecutiveStraight);

                    if (!straightOk || wantsMeander || forceMeander) {
                        let wantsLong = (randomInt(rng, 0, 99) < config.riverHorizontalChance);
                        let targetChange = wantsLong ? randomInt(rng, 1, 3) : 1;

                        let candidates = [];

                        // Try Right
                        if (currentCol + targetChange < this.width) {
                            let valid = true;
                            let testCol = currentCol;
                            for (let s = 0; s < targetChange && valid; ++s) {
                                if (!checkPathValid(az, testCol, testCol + 1)) valid = false;
                                else testCol++;
                            }
                            if (valid) candidates.push(currentCol + targetChange);
                        }

                        // Try Left
                        if (currentCol - targetChange >= 0) {
                            let valid = true;
                            let testCol = currentCol;
                            for (let s = 0; s < targetChange && valid; ++s) {
                                if (!checkPathValid(az, testCol, testCol - 1)) valid = false;
                                else testCol--;
                            }
                            if (valid) candidates.push(currentCol - targetChange);
                        }

                        // Fallback
                        if (candidates.length === 0) {
                            if (currentCol > 0 && checkPathValid(az, currentCol, currentCol - 1)) candidates.push(currentCol - 1);
                            if (currentCol < this.width - 1 && checkPathValid(az, currentCol, currentCol + 1)) candidates.push(currentCol + 1);
                        }

                        if (candidates.length > 0) {
                            let idx = randomInt(rng, 0, candidates.length - 1);
                            nextCol = candidates[idx];
                            consecutiveStraight = 0;
                        } else {
                            // If forced to go straight even if 'bad' (shouldn't happen with good layout), keep straight
                            consecutiveStraight++;
                        }
                    } else {
                        consecutiveStraight++;
                    }

                    colTargets[az + 1] = nextCol;
                    currentCol = nextCol;
                }

                // Calculate Center X for every row
                const riverCenterX = new Array(totalH);
                for (let z = 0; z < totalH; ++z) {
                    let currAcre = Math.floor(z / ACRE_SIZE);
                    let nextAcre = Math.min(currAcre + 1, this.height - 1);
                    let localZ = z % ACRE_SIZE;
                    let targetCol = (localZ < RIVER_CONNECTION_POINT) ? colTargets[currAcre] : colTargets[nextAcre];
                    riverCenterX[z] = targetCol * ACRE_SIZE + RIVER_CONNECTION_POINT;
                }

                // Carve
                for (let z = 0; z < totalH; ++z) {
                    let centerX = riverCenterX[z];

                    // Handle Horizontal segments visually
                    if (z > 0 && (z % ACRE_SIZE) === RIVER_CONNECTION_POINT) {
                        let prevX = riverCenterX[z - 1];
                        if (prevX !== centerX) {
                            let dir = Math.sign(centerX - prevX);
                            for (let x = prevX; x !== centerX + dir; x += dir) {
                                this._carveRiver(x, z, halfW, totalW, totalH, recorder);
                            }
                            continue;
                        }
                    }

                    this._carveRiver(centerX, z, halfW, totalW, totalH, recorder);
                }

                this._createMouths(recorder, rng);
            }

            _carveRiver(cx, cz, hw, tw, th, recorder) {
                for (let dx = -hw; dx <= hw; ++dx) {
                    for (let dz = -hw; dz <= hw; ++dz) {
                        let wx = cx + dx, wz = cz + dz;
                        if (wx >= 0 && wx < tw && wz >= 0 && wz < th) {
                            let t = this.getTile(wx, wz);
                            let isMouth = (t.type === TileType.SAND || t.type === TileType.OCEAN);
                            t.type = isMouth ? TileType.RIVER_MOUTH : TileType.RIVER;
                            if (recorder) recorder.push({ type: 'tile', x: wx, z: wz, val: t.type, msg: 'River' });
                        }
                    }
                }
            }

            _createMouths(recorder, rng) {
                const totalW = this.width * ACRE_SIZE;
                const totalH = this.height * ACRE_SIZE;
                let mouthZ = -1;
                let mouthXs = [];

                // 1. Detect Mouths
                for (let z = 0; z < totalH; ++z) {
                    for (let x = 0; x < totalW; ++x) {
                        let t = this.getTile(x, z);
                        if (t.type !== TileType.RIVER) continue;

                        let touches = false;
                        [[1, 0], [-1, 0], [0, 1], [0, -1]].forEach(([dx, dz]) => {
                            let nx = x + dx, nz = z + dz;
                            if (nx >= 0 && nx < totalW && nz >= 0 && nz < totalH) {
                                let nt = this.getTile(nx, nz);
                                if (nt.type === TileType.OCEAN || nt.type === TileType.SAND) touches = true;
                            }
                        });

                        if (touches) {
                            t.type = TileType.RIVER_MOUTH;
                            if (mouthZ === -1 || mouthZ === z) {
                                mouthZ = z;
                                mouthXs.push(x);
                            }
                        }
                    }
                }

                // 2. Refined Teardrops at Mouth
                if (mouthXs.length > 0) {
                    let minX = Math.min(...mouthXs);
                    let maxX = Math.max(...mouthXs);

                    let oceanRow = this.height - 1;
                    let localZ = (mouthZ % ACRE_SIZE) - 4;

                    Utils.createGrassTeardrop(this, oceanRow, minX - 2, localZ, 5, 8, -1.0, totalW, recorder);
                    Utils.createGrassTeardrop(this, oceanRow, maxX + 2, localZ, 5, 8, 1.0, totalW, recorder);
                }

                // 3. Cleanup Sand
                for (let z = 0; z < totalH; ++z) {
                    for (let x = 0; x < totalW; ++x) {
                        let t = this.getTile(x, z);
                        if (t.type === TileType.RIVER || t.type === TileType.RIVER_MOUTH) {
                            [[1, 0], [-1, 0], [0, 1], [0, -1]].forEach(([dx, dz]) => {
                                let nx = x + dx, nz = z + dz;
                                if (nx >= 0 && nx < totalW && nz >= 0 && nz < totalH) {
                                    if (this.getTile(nx, nz).type === TileType.SAND) {
                                        this.getTile(nx, nz).type = TileType.GRASS;
                                        if (recorder) recorder.push({ type: 'tile', x: nx, z: nz, val: TileType.GRASS, msg: 'Cleanup Sand' });
                                    }
                                }
                            });
                        }
                    }
                }
            }

            // ‚îÄ‚îÄ 4. RAMP GENERATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            generateRamps(rng, config, recorder) {
                const totalW = this.width * ACRE_SIZE;
                const totalH = this.height * ACRE_SIZE;

                const isWalkable = (t) => !Utils.isAnyWater(t.type);

                const canPlace = (wx, wz, fromElev, toElev) => {
                    let u = this.getTile(wx, wz);
                    let l = this.getTile(wx, wz + 1);
                    if (u.elevation !== fromElev || l.elevation !== toElev) return false;
                    if (fromElev !== toElev + 1) return false;
                    return isWalkable(u) && isWalkable(l);
                };

                const isWaterNearby = (wx, wz) => {
                    let r = 4; // Check radius
                    for (let z = wz - r; z <= wz + r; ++z) {
                        for (let x = wx - r; x <= wx + r; ++x) {
                            if (x >= 0 && x < totalW && z >= 0 && z < totalH) {
                                if (Utils.isAnyWater(this.getTile(x, z).type)) return true;
                            }
                        }
                    }
                    return false;
                };

                const findCandidates = (fromE, toE, minX, maxX) => {
                    let cands = [];
                    for (let wz = 1; wz < totalH - 1; ++wz) {
                        for (let wx = minX; wx < maxX; ++wx) {
                            if (!canPlace(wx, wz, fromE, toE)) continue;
                            if (isWaterNearby(wx, wz)) continue;

                            let score = Math.min(wx - minX, maxX - wx);
                            let wWall = (this.getTile(wx - 1, wz).type === TileType.CLIFF);
                            let eWall = (this.getTile(wx + 1, wz).type === TileType.CLIFF);
                            if (!wWall || !eWall) score -= 5;

                            cands.push({ x: wx, z: wz, s: score });
                        }
                    }
                    return cands;
                };

                const placeRamp = (c) => {
                    for (let z = 0; z < 2; ++z) {
                        for (let x = -1; x <= 1; ++x) {
                            let t = this.getTile(c.x + x, c.z + z);
                            if (isWalkable(t)) {
                                t.type = TileType.GRASS;
                                t.elevation = (z === 0) ? (this.getTile(c.x, c.z).elevation) : (this.getTile(c.x, c.z).elevation - 1);
                            }
                        }
                    }
                    for (let z = 0; z < 2; ++z) {
                        let t = this.getTile(c.x, c.z + z);
                        t.type = TileType.RAMP;
                        if (recorder) recorder.push({ type: 'tile', x: c.x, z: c.z + z, val: TileType.RAMP, msg: 'Ramp' });
                    }
                };

                let midX = Math.floor(totalW / 2);
                let w2 = findCandidates(2, 1, 0, midX).sort((a, b) => b.s - a.s);
                let e2 = findCandidates(2, 1, midX, totalW).sort((a, b) => b.s - a.s);

                if (w2.length) placeRamp(w2[randomInt(rng, 0, Math.min(2, w2.length - 1))]);
                if (e2.length) placeRamp(e2[randomInt(rng, 0, Math.min(2, e2.length - 1))]);

                let w1 = findCandidates(1, 0, 0, midX).sort((a, b) => b.s - a.s);
                let e1 = findCandidates(1, 0, midX, totalW).sort((a, b) => b.s - a.s);

                if (w1.length) placeRamp(w1[randomInt(rng, 0, Math.min(2, w1.length - 1))]);
                if (e1.length) placeRamp(e1[randomInt(rng, 0, Math.min(2, e1.length - 1))]);
            }

            // ‚îÄ‚îÄ 5. POND GENERATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            generatePonds(rng, config, recorder) {
                const totalW = this.width * ACRE_SIZE;
                const totalH = this.height * ACRE_SIZE;
                const oceanZ = (this.height - 1) * ACRE_SIZE;

                let acreScores = [];
                for (let ay = 0; ay < this.height - 1; ++ay) {
                    for (let ax = 0; ax < this.width; ++ax) {
                        let score = 0;
                        for (let lz = 0; lz < ACRE_SIZE; ++lz) {
                            for (let lx = 0; lx < ACRE_SIZE; ++lx) {
                                let t = this.acres[ax][ay].tiles[lz][lx];
                                if (Utils.isAnyWater(t.type) || t.type === TileType.CLIFF || t.type === TileType.RAMP) score++;
                            }
                        }
                        acreScores.push({ pos: { x: ax, y: ay }, s: score });
                    }
                }
                acreScores.sort((a, b) => a.s - b.s);

                let r = randomInt(rng, 2, 4);
                let shape = randomInt(rng, 0, 2);

                let valid = false;
                let center = { x: 0, y: 0 };

                const canPlacePond = (cx, cy, rad) => {
                    let buf = rad + 2;
                    if (cx < buf || cx >= totalW - buf || cy < buf || cy >= oceanZ - buf) return false;
                    for (let z = cy - buf; z <= cy + buf; ++z) {
                        for (let x = cx - buf; x <= cx + buf; ++x) {
                            let t = this.getTile(x, z);
                            if (Utils.isAnyWater(t.type) || t.type === TileType.CLIFF || t.type === TileType.RAMP) return false;
                        }
                    }
                    return true;
                };

                for (let cand of acreScores) {
                    let ax = cand.pos.x * ACRE_SIZE + 8;
                    let ay = cand.pos.y * ACRE_SIZE + 8;

                    for (let att = 0; att < 5; ++att) {
                        let tx = ax + randomInt(rng, -4, 4);
                        let ty = ay + randomInt(rng, -4, 4);
                        if (canPlacePond(tx, ty, r)) {
                            center = { x: tx, y: ty };
                            valid = true;
                            break;
                        }
                    }
                    if (valid) break;
                }

                if (!valid) return;

                let painted = new Set();
                let queue = [];

                let maxDim = r + 2;
                for (let z = center.y - maxDim; z <= center.y + maxDim; z += 2) {
                    for (let x = center.x - maxDim; x <= center.x + maxDim; x += 2) {
                        let dx = (x - center.x) / r;
                        let dz = (z - center.y) / r;
                        let dist = Math.sqrt(dx * dx + dz * dz);
                        if (dist <= 1.0) queue.push({ x: x, z: z });
                    }
                }

                while (queue.length > 0) {
                    let p = queue.shift();
                    for (let dz = -1; dz <= 2; ++dz) {
                        for (let dx = -1; dx <= 2; ++dx) {
                            let bx = p.x + dx;
                            let bz = p.z + dz;
                            if (bx >= 0 && bx < totalW && bz >= 0 && bz < totalH) {
                                let key = bx + "," + bz;
                                if (!painted.has(key)) {
                                    let t = this.getTile(bx, bz);
                                    if (!Utils.isAnyWater(t.type) && t.type !== TileType.CLIFF && t.type !== TileType.RAMP) {
                                        t.type = TileType.POND;
                                        painted.add(key);
                                        if (recorder) recorder.push({ type: 'tile', x: bx, z: bz, val: TileType.POND, msg: 'Pond' });
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // ‚îÄ‚îÄ Application State & UI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let app = {
            town: null,
            steps: [],
            index: 0,
            timer: null,
            paused: true
        };

        const Colors = {
            [TileType.GRASS]: ['#4C9933', '#72BF4C', '#99E566'],
            [TileType.SAND]: '#DCC69E',
            [TileType.OCEAN]: '#1966CC',
            [TileType.RIVER]: '#4FC3F7',
            [TileType.RIVER_MOUTH]: '#1676d1',
            [TileType.CLIFF]: '#7F7366',
            [TileType.RAMP]: '#A1887F',
            [TileType.POND]: '#00BCD4'
        };

        function render() {
            const tileSize = parseInt(document.getElementById('tileSize').value);
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const totalWidth = app.town.width * ACRE_SIZE;
            const totalHeight = app.town.height * ACRE_SIZE;

            canvas.width = totalWidth * tileSize;
            canvas.height = totalHeight * tileSize;

            for (let x = 0; x < totalWidth; x++) {
                for (let z = 0; z < totalHeight; z++) {
                    const t = app.town.getTile(x, z);
                    let fill = Colors[t.type];
                    if (Array.isArray(fill)) fill = fill[t.elevation] || fill[0];

                    ctx.fillStyle = fill;
                    ctx.fillRect(x * tileSize, z * tileSize, tileSize, tileSize);
                }
            }
        }

        function getConfig() {
            return {
                minPlateauRow: parseInt(document.getElementById('minPlateauRow').value),
                maxPlateauRow: parseInt(document.getElementById('maxPlateauRow').value),
                highPlateauChance: parseFloat(document.getElementById('highPlateauChance').value),
                riverWidth: parseInt(document.getElementById('riverWidth').value),
                riverMeanderChance: parseInt(document.getElementById('riverMeanderChance').value),
                riverHorizontalChance: parseInt(document.getElementById('riverHorizontalChance').value),
            };
        }

        function generateInstant() {
            stopDebug();
            const w = parseInt(document.getElementById('width').value);
            const h = parseInt(document.getElementById('height').value);
            const seed = BigInt(document.getElementById('seed').value);

            app.town = new Town(w, h);
            app.town.reset();

            const rng = new MT19937_64(seed);
            const config = getConfig();

            app.town.generateOcean(rng, config, null);
            app.town.generateCliffs(rng, config, null);
            app.town.generateRivers(rng, config, null);
            app.town.generateRamps(rng, config, null);
            app.town.generatePonds(rng, config, null);

            render();
            document.getElementById('debugInfo').textContent = "Generated.";
        }

        function startDebug() {
            stopDebug();
            const w = parseInt(document.getElementById('width').value);
            const h = parseInt(document.getElementById('height').value);
            const seed = BigInt(document.getElementById('seed').value);
            const config = getConfig();

            const simTown = new Town(w, h);
            simTown.reset();
            const rng = new MT19937_64(seed);
            app.steps = [];

            simTown.generateOcean(rng, config, app.steps);
            simTown.generateCliffs(rng, config, app.steps);
            simTown.generateRivers(rng, config, app.steps);
            simTown.generateRamps(rng, config, app.steps);
            simTown.generatePonds(rng, config, app.steps);

            app.town = new Town(w, h);
            app.town.reset();
            app.index = 0;
            app.paused = false;

            const tl = document.getElementById('timeline');
            tl.max = app.steps.length;
            tl.value = 0;
            tl.disabled = false;
            document.getElementById('btnPause').disabled = false;
            document.getElementById('btnStep').disabled = false;
            document.getElementById('btnPause').textContent = "Pause";

            render();
            runLoop();
        }

        function runLoop() {
            clearInterval(app.timer);
            if (!app.paused) {
                const slider = document.getElementById('animSpeed');
                const delay = (parseInt(slider.max) - parseInt(slider.value)) + 1;
                app.timer = setInterval(() => step(), delay);
            }
        }

        function step() {
            if (app.index >= app.steps.length) {
                app.paused = true;
                document.getElementById('btnPause').textContent = "Restart";
                return;
            }
            applyStep(app.steps[app.index]);
            app.index++;
            updateUI();
            if (app.index % 10 === 0) render();
            if (app.index === app.steps.length) render();
        }

        function applyStep(s) {
            const tile = app.town.getTile(s.x, s.z);
            if (s.type === 'elev') tile.elevation = s.val;
            if (s.type === 'tile') tile.type = s.val;
            document.getElementById('debugInfo').textContent = `[${app.index}] ${s.msg}`;
        }

        function scrub(val) {
            app.paused = true;
            document.getElementById('btnPause').textContent = "Resume";
            const w = parseInt(document.getElementById('width').value);
            const h = parseInt(document.getElementById('height').value);
            app.town = new Town(w, h);
            app.town.reset();
            app.index = 0;
            const target = parseInt(val);
            for (let i = 0; i < target; i++) {
                applyStep(app.steps[i]);
                app.index++;
            }
            updateUI();
            render();
        }

        function togglePause() {
            if (app.index >= app.steps.length) {
                startDebug();
                return;
            }
            app.paused = !app.paused;
            document.getElementById('btnPause').textContent = app.paused ? "Resume" : "Pause";
            if (!app.paused) runLoop();
            else clearInterval(app.timer);
        }

        function stopDebug() {
            clearInterval(app.timer);
            app.paused = true;
            document.getElementById('btnPause').disabled = true;
            document.getElementById('btnStep').disabled = true;
            document.getElementById('timeline').disabled = true;
        }

        function updateUI() {
            document.getElementById('timeline').value = app.index;
            document.getElementById('stepDisplay').textContent = app.index;
        }

        function randomSeed() {
            document.getElementById('seed').value = Math.floor(Math.random() * 1000000).toString();
            generateInstant();
        }

        window.onload = generateInstant;
    </script>
</body>

</html>