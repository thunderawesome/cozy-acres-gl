<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cozy Town Generation Debugger</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #f0f0f0;
            padding: 20px;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: #4CAF50;
            margin-bottom: 20px;
        }

        .main-layout {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }

        .controls-panel {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            width: 300px;
            flex-shrink: 0;
        }

        .control-section {
            margin-bottom: 15px;
            border-bottom: 1px solid #444;
            padding-bottom: 15px;
        }

        .control-section:last-child {
            border-bottom: none;
        }

        .section-header {
            color: #4CAF50;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .input-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        label {
            font-size: 0.85em;
            color: #ccc;
        }

        input[type="number"],
        input[type="text"] {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            width: 60px;
            text-align: right;
        }

        input[type="range"] {
            width: 100%;
        }

        button {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
        }

        .btn-secondary {
            background: #555;
            color: white;
        }

        .btn-secondary:hover {
            background: #666;
        }

        .btn-secondary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #canvas-container {
            position: relative;
        }

        canvas {
            background: #000;
            border: 2px solid #444;
            image-rendering: pixelated;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .info-panel {
            margin-top: 10px;
            background: #222;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.85em;
            max-width: 100%;
        }

        .legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            margin-top: 10px;
            font-size: 0.8em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .swatch {
            width: 16px;
            height: 16px;
            border: 1px solid #555;
        }
    </style>
</head>

<body>

    <h1>Cozy Town Generator (C++ Port)</h1>

    <div class="main-layout">
        <div class="controls-panel">
            <div class="control-section">
                <div class="section-header">World</div>
                <div class="input-group">
                    <label>Seed</label>
                    <input type="number" id="seed" value="12345">
                </div>
                <div class="input-group">
                    <label>Width (Acres)</label>
                    <input type="number" id="width" value="5" min="2" max="10">
                </div>
                <div class="input-group">
                    <label>Height (Acres)</label>
                    <input type="number" id="height" value="6" min="2" max="10">
                </div>
            </div>

            <div class="control-section">
                <div class="section-header">Cliffs</div>
                <div class="input-group">
                    <label>Min Plateau Row</label>
                    <input type="number" id="minPlateauRow" value="1">
                </div>
                <div class="input-group">
                    <label>Max Plateau Row</label>
                    <input type="number" id="maxPlateauRow" value="4">
                </div>
                <div class="input-group">
                    <label>High Chance (0-1)</label>
                    <input type="number" id="highPlateauChance" value="0.75" step="0.05">
                </div>
            </div>

            <div class="control-section">
                <div class="section-header">Rivers</div>
                <div class="input-group">
                    <label>Width</label>
                    <input type="number" id="riverWidth" value="3">
                </div>
                <div class="input-group">
                    <label>Meander %</label>
                    <input type="number" id="riverMeanderChance" value="50">
                </div>
                <div class="input-group">
                    <label>Horizontal %</label>
                    <input type="number" id="riverHorizontalChance" value="50">
                </div>
            </div>

            <div class="control-section">
                <div class="section-header">Visualization</div>
                <div class="input-group">
                    <label>Tile Size</label>
                    <input type="range" id="tileSize" min="2" max="12" value="6">
                </div>
                <div class="input-group">
                    <label>Speed (ms)</label>
                    <input type="range" id="animSpeed" min="1" max="200" value="20">
                </div>
            </div>

            <button class="btn-primary" onclick="generateInstant()">‚ö° Instant Generate</button>
            <button class="btn-primary" onclick="randomSeed()">? Shuffle</button>
            <button class="btn-primary" style="background:#8b8b00" onclick="startDebug()">üêõ Debug / Animate</button>

            <div style="display:flex; gap:5px;">
                <button class="btn-secondary" id="btnPause" onclick="togglePause()" disabled>Pause</button>
                <button class="btn-secondary" id="btnStep" onclick="step()" disabled>Step</button>
            </div>

            <div class="control-section">
                <label>Timeline: <span id="stepDisplay">0</span></label>
                <input type="range" id="timeline" value="0" disabled oninput="scrub(this.value)">
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="canvas"></canvas>

            <div class="legend">
                <div class="legend-item">
                    <div class="swatch" style="background:rgb(76,153,51)"></div>Grass L0
                </div>
                <div class="legend-item">
                    <div class="swatch" style="background:rgb(114,191,76)"></div>Grass L1
                </div>
                <div class="legend-item">
                    <div class="swatch" style="background:rgb(153,229,102)"></div>Grass L2
                </div>
                <div class="legend-item">
                    <div class="swatch" style="background:rgb(127,115,102)"></div>Cliff
                </div>
                <div class="legend-item">
                    <div class="swatch" style="background:rgb(25,102,204)"></div>Water
                </div>
            </div>

            <div class="info-panel" id="debugInfo">Ready.</div>
        </div>
    </div>

    <script>
        // ‚îÄ‚îÄ Constants matching C++ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const ACRE_SIZE = 16;
        const CLIFF_CONNECTION_POINT = 12; // From TownConfig.h
        const RIVER_CONNECTION_POINT = 3;  // From TownConfig.h

        // ‚îÄ‚îÄ RNG shim to match std::mt19937 roughly ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function seededRandom(seed) {
            let state = BigInt(seed);
            return () => {
                // Linear Congruential Generator parameters usually used for minstd_rand
                // but essentially we just need deterministic output.
                state = (state * 1664525n + 1013904223n) & 0xFFFFFFFFn;
                return Number(state) / 4294967296;
            };
        }

        // Inclusive min, inclusive max
        function randomInt(rng, min, max) {
            return Math.floor(rng() * (max - min + 1)) + min;
        }

        // ‚îÄ‚îÄ Logic Classes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        class Town {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.acres = [];

                // Initialize grid
                for (let x = 0; x < width; x++) {
                    this.acres[x] = [];
                    for (let y = 0; y < height; y++) {
                        this.acres[x][y] = {
                            tiles: Array(ACRE_SIZE).fill(null).map(() =>
                                Array(ACRE_SIZE).fill(null).map(() => ({
                                    type: 'GRASS',
                                    elevation: 0
                                }))
                            )
                        };
                    }
                }
            }

            // Matches Town::WorldToTile logic
            worldToTile(wx, wz) {
                wx = Math.max(0, Math.min(wx, (this.width * ACRE_SIZE) - 1));
                wz = Math.max(0, Math.min(wz, (this.height * ACRE_SIZE) - 1));
                return {
                    ax: Math.floor(wx / ACRE_SIZE),
                    az: Math.floor(wz / ACRE_SIZE),
                    lx: wx % ACRE_SIZE,
                    lz: wz % ACRE_SIZE
                };
            }

            // Matches Town::GetElevation
            getElevation(wx, wz) {
                if (wx < 0 || wx >= this.width * ACRE_SIZE ||
                    wz < 0 || wz >= this.height * ACRE_SIZE) return -1;

                const pos = this.worldToTile(wx, wz);
                return this.acres[pos.ax][pos.az].tiles[pos.lz][pos.lx].elevation;
            }

            getTile(wx, wz) {
                const pos = this.worldToTile(wx, wz);
                return this.acres[pos.ax][pos.az].tiles[pos.lz][pos.lx];
            }

            // ‚îÄ‚îÄ CLIFF GENERATION STEP (Matches CliffGenerationStep.cpp) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            generateCliffs(rng, config, recorder) {
                const totalWidth = this.width * ACRE_SIZE;
                const totalHeight = this.height * ACRE_SIZE;

                // 1. Decide structure
                // std::bernoulli_distribution check
                const useThreeTiers = rng() < config.highPlateauChance;

                let minPlateauRow = config.minPlateauRow;
                if (useThreeTiers) {
                    minPlateauRow += 2;
                }

                // 2. Mid plateau (always present)
                const midTargets = [];
                for (let ax = 0; ax < this.width; ax++) {
                    // (mid_dist(rng) + 1) * Acre::SIZE
                    const row = randomInt(rng, minPlateauRow, config.maxPlateauRow);
                    midTargets[ax] = (row + 1) * ACRE_SIZE;
                }

                // Helper: BuildSteppedBoundary
                const buildSteppedBoundary = (targets, connPoint) => {
                    const boundary = new Array(totalWidth);
                    for (let x = 0; x < totalWidth; x++) {
                        const currAcre = Math.floor(x / ACRE_SIZE);
                        const nextAcre = Math.min(currAcre + 1, this.width - 1);
                        const localX = x % ACRE_SIZE;
                        boundary[x] = (localX <= connPoint) ? targets[currAcre] : targets[nextAcre];
                    }
                    return boundary;
                };

                const midBoundary = buildSteppedBoundary(midTargets, CLIFF_CONNECTION_POINT);

                // 3. Optional high plateau
                let highBoundary = new Array(totalWidth).fill(0);
                if (useThreeTiers) {
                    const highTargets = [];
                    for (let ax = 0; ax < this.width; ax++) {
                        // std::uniform_int_distribution<int> high_dist
                        const candidate = (randomInt(rng, config.minHighOffset, config.maxHighOffset) + 1) * ACRE_SIZE;
                        const maxAllowed = midTargets[ax] - ACRE_SIZE;
                        // std::clamp
                        highTargets[ax] = Math.max(ACRE_SIZE, Math.min(candidate, maxAllowed));
                    }

                    highBoundary = buildSteppedBoundary(highTargets, CLIFF_CONNECTION_POINT);

                    // Safety clamp
                    for (let x = 0; x < totalWidth; x++) {
                        const acreX = Math.floor(x / ACRE_SIZE);
                        const safeMax = midTargets[acreX] - ACRE_SIZE;
                        highBoundary[x] = Math.min(highBoundary[x], safeMax);
                        highBoundary[x] = Math.max(highBoundary[x], 0);
                    }
                }

                // 4. Apply Elevations (ComputeSnappedElevation logic)
                for (let wx = 0; wx < totalWidth; wx++) {
                    for (let wz = 0; wz < totalHeight; wz++) {
                        // Determine naive elevation
                        let naive = 0;
                        if (wz < midBoundary[wx]) naive = 1;
                        if (useThreeTiers && wz < highBoundary[wx]) naive = 2;

                        // ComputeSnappedElevation logic
                        let snapped = 0;
                        const localZ = wz % ACRE_SIZE;

                        if (localZ === CLIFF_CONNECTION_POINT) {
                            snapped = naive;
                        } else {
                            const currAcreZ = Math.floor(wz / ACRE_SIZE);
                            const targetAcreZ = (localZ < CLIFF_CONNECTION_POINT) ? currAcreZ : currAcreZ + 1;

                            if (targetAcreZ >= this.height) {
                                snapped = naive;
                            } else {
                                const checkZ = targetAcreZ * ACRE_SIZE + CLIFF_CONNECTION_POINT;
                                if (checkZ >= totalHeight) {
                                    snapped = naive;
                                } else {
                                    let result = 0;
                                    if (checkZ < midBoundary[wx]) result = 1;
                                    if (useThreeTiers && checkZ < highBoundary[wx]) result = 2;
                                    snapped = result;
                                }
                            }
                        }

                        // Apply
                        const tile = this.getTile(wx, wz);
                        tile.elevation = snapped;

                        if (recorder) recorder.push({
                            type: 'elev', x: wx, z: wz, val: snapped,
                            msg: `Set elevation to ${snapped}`
                        });
                    }
                }

                // Tag Cliff Faces
                const dx = [1, -1, 0, 0];
                const dz = [0, 0, 1, -1];

                for (let wx = 0; wx < totalWidth; wx++) {
                    for (let wz = 0; wz < totalHeight; wz++) {
                        const tile = this.getTile(wx, wz);
                        if (tile.elevation <= 0) continue;

                        let isCliff = false;
                        for (let d = 0; d < 4; d++) {
                            const nx = wx + dx[d];
                            const nz = wz + dz[d];
                            if (nx < 0 || nx >= totalWidth || nz < 0 || nz >= totalHeight) continue;

                            const neighbor = this.getTile(nx, nz);
                            if (neighbor.elevation < tile.elevation) {
                                isCliff = true;
                                break;
                            }
                        }

                        if (isCliff) {
                            tile.type = 'CLIFF';
                            if (recorder) recorder.push({
                                type: 'cliff', x: wx, z: wz, val: 'CLIFF',
                                msg: `Tagged as Cliff`
                            });
                        }
                    }
                }
            }

            // ‚îÄ‚îÄ RIVER GENERATION STEP (Matches RiverGenerationStep.cpp) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            generateRivers(rng, config, recorder) {
                const totalWidth = this.width * ACRE_SIZE;
                const totalHeight = this.height * ACRE_SIZE;
                const halfWidth = Math.floor(config.riverWidth / 2);

                // Helper: CheckPathValid
                const checkPathValid = (acreZ, entryCol, exitCol) => {
                    const entryX = entryCol * ACRE_SIZE + RIVER_CONNECTION_POINT;
                    const exitX = exitCol * ACRE_SIZE + RIVER_CONNECTION_POINT;
                    const baseZ = acreZ * ACRE_SIZE;

                    let riverElev = this.getElevation(entryX, baseZ);
                    if (riverElev === -1) return false;

                    const update = (x, z) => {
                        const elev = this.getElevation(x, z);
                        // River cannot flow UP. 
                        if (elev === -1 || elev > riverElev) return false;
                        riverElev = Math.min(riverElev, elev);
                        return true;
                    };

                    // 1. Vertical segment before bend
                    for (let lz = 0; lz < RIVER_CONNECTION_POINT; lz++) {
                        if (!update(entryX, baseZ + lz)) return false;
                    }

                    // 2. Bend Point
                    if (!update(entryX, baseZ + RIVER_CONNECTION_POINT)) return false;

                    // 3. Horizontal segment (bend)
                    const dirX = (exitX > entryX) ? 1 : ((exitX < entryX) ? -1 : 0);
                    const steps = Math.abs(exitX - entryX);
                    let currX = entryX;
                    for (let i = 0; i < steps; i++) {
                        currX += dirX;
                        if (!update(currX, baseZ + RIVER_CONNECTION_POINT)) return false;
                    }

                    // 4. Vertical segment after bend
                    for (let lz = RIVER_CONNECTION_POINT + 1; lz < ACRE_SIZE; lz++) {
                        if (!update(exitX, baseZ + lz)) return false;
                    }

                    return true;
                };

                // Helper: CarveRiverSection
                const carveSection = (cx, cz) => {
                    for (let dx = -halfWidth; dx <= halfWidth; dx++) {
                        for (let dz = -halfWidth; dz <= halfWidth; dz++) {
                            const wx = cx + dx;
                            const wz = cz + dz;
                            if (wx >= 0 && wx < totalWidth && wz >= 0 && wz < totalHeight) {
                                this.getTile(wx, wz).type = 'WATER';
                                if (recorder) recorder.push({
                                    type: 'water', x: wx, z: wz, val: 'WATER',
                                    msg: `Carving river at ${wx},${wz}`
                                });
                            }
                        }
                    }
                };

                // Generate target column for each acre row
                const columnTargets = new Array(this.height);
                let currentCol = randomInt(rng, 0, this.width - 1);
                columnTargets[0] = currentCol;

                let consecutiveStraight = 0;
                const maxConsecutive = 2;

                for (let az = 0; az < this.height - 1; az++) {
                    let nextCol = currentCol;
                    const straightOk = checkPathValid(az, currentCol, currentCol);
                    const wantsMeander = (randomInt(rng, 0, 99) < config.riverMeanderChance);
                    const forceMeander = (consecutiveStraight >= maxConsecutive);

                    if (!straightOk || wantsMeander || forceMeander) {
                        const wantsLong = (randomInt(rng, 0, 99) < config.riverHorizontalChance);
                        let targetChange = 1;
                        if (wantsLong) targetChange = randomInt(rng, 1, 3); // horizontal_length(1, 3)

                        const candidates = [];

                        // Try moving right
                        if (currentCol + targetChange < this.width) {
                            let valid = true;
                            let testCol = currentCol;
                            for (let s = 0; s < targetChange && valid; s++) {
                                // Check if we can move from testCol -> testCol+1
                                if (!checkPathValid(az, testCol, testCol + 1)) valid = false;
                                else testCol++;
                            }
                            if (valid) candidates.push(currentCol + targetChange);
                        }

                        // Try moving left
                        if (currentCol - targetChange >= 0) {
                            let valid = true;
                            let testCol = currentCol;
                            for (let s = 0; s < targetChange && valid; s++) {
                                if (!checkPathValid(az, testCol, testCol - 1)) valid = false;
                                else testCol--;
                            }
                            if (valid) candidates.push(currentCol - targetChange);
                        }

                        // Fallback: single steps
                        if (candidates.length === 0) {
                            if (currentCol > 0 && checkPathValid(az, currentCol, currentCol - 1))
                                candidates.push(currentCol - 1);
                            if (currentCol < this.width - 1 && checkPathValid(az, currentCol, currentCol + 1))
                                candidates.push(currentCol + 1);
                        }

                        if (candidates.length > 0) {
                            // shuffle candidates
                            const idx = randomInt(rng, 0, candidates.length - 1);
                            nextCol = candidates[idx];
                            consecutiveStraight = 0;
                        } else if (!forceMeander) {
                            consecutiveStraight++;
                        } else {
                            // Forced to meander but failed... stay straight
                            consecutiveStraight++;
                        }
                    } else {
                        consecutiveStraight++;
                    }

                    columnTargets[az + 1] = nextCol;
                    currentCol = nextCol;
                }

                // Build river center map
                const riverCenterX = new Array(totalHeight);
                for (let z = 0; z < totalHeight; z++) {
                    const currAcre = Math.floor(z / ACRE_SIZE);
                    const nextAcre = Math.min(currAcre + 1, this.height - 1);
                    const localZ = z % ACRE_SIZE;

                    const targetCol = (localZ < RIVER_CONNECTION_POINT)
                        ? columnTargets[currAcre] : columnTargets[nextAcre];

                    riverCenterX[z] = targetCol * ACRE_SIZE + RIVER_CONNECTION_POINT;
                }

                // Carve
                for (let z = 0; z < totalHeight; z++) {
                    const centerX = riverCenterX[z];

                    // Handle Bend (Horizontal filling)
                    if (z > 0 && (z % ACRE_SIZE) === RIVER_CONNECTION_POINT) {
                        const prevX = riverCenterX[z - 1];
                        if (prevX !== centerX) {
                            const dir = (centerX > prevX) ? 1 : -1;
                            for (let x = prevX; x !== centerX + dir; x += dir) {
                                carveSection(x, z);
                            }
                            continue;
                        }
                    }
                    carveSection(centerX, z);
                }
            }
        }


        // ‚îÄ‚îÄ Rendering & App State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let appState = {
            town: null,
            config: {},
            steps: [],
            currentStepIndex: 0,
            isPlaying: false,
            interval: null
        };

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function getConfig() {
            return {
                minPlateauRow: parseInt(document.getElementById('minPlateauRow').value),
                maxPlateauRow: parseInt(document.getElementById('maxPlateauRow').value),
                minHighOffset: 1, // hardcoded in UI for simplicity, matches C++ TownConfig default
                maxHighOffset: 2,
                highPlateauChance: parseFloat(document.getElementById('highPlateauChance').value),
                riverWidth: parseInt(document.getElementById('riverWidth').value),
                riverMeanderChance: parseInt(document.getElementById('riverMeanderChance').value),
                riverHorizontalChance: parseInt(document.getElementById('riverHorizontalChance').value),
            };
        }

        function renderTown(town, tileSize, highlight = null) {
            const totalWidth = town.width * ACRE_SIZE;
            const totalHeight = town.height * ACRE_SIZE;

            canvas.width = totalWidth * tileSize;
            canvas.height = totalHeight * tileSize;

            for (let x = 0; x < totalWidth; x++) {
                for (let y = 0; y < totalHeight; y++) {
                    const tile = town.getTile(x, y);

                    let fill = '';

                    // Colors extracted from Town.cpp GenerateRenderData
                    if (tile.type === 'WATER') {
                        // C++: 0.1*depth, 0.4*depth, 0.8*depth. depth = 1.0 - (elev*0.1)
                        const depth = 1.0 - (tile.elevation * 0.1);
                        const r = Math.floor(255 * 0.1 * depth);
                        const g = Math.floor(255 * 0.4 * depth);
                        const b = Math.floor(255 * 0.8 * depth);
                        fill = `rgb(${r},${g},${b})`;
                    } else if (tile.type === 'CLIFF') {
                        // C++: 0.5, 0.45, 0.4
                        fill = `rgb(127,115,102)`;
                    } else {
                        // Grass
                        // C++: light = 0.5 + (elev * 0.15)
                        // color: 0.3*light, 0.6*light, 0.2*light
                        const light = 0.5 + (tile.elevation * 0.15);
                        const r = Math.floor(255 * 0.3 * light);
                        const g = Math.floor(255 * 0.6 * light);
                        const b = Math.floor(255 * 0.2 * light);
                        fill = `rgb(${r},${g},${b})`;
                    }

                    ctx.fillStyle = fill;
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);

                    // Grid lines (Acre borders)
                    if (x % ACRE_SIZE === 0 || y % ACRE_SIZE === 0) {
                        ctx.fillStyle = 'rgba(255,255,255,0.1)';
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    }
                }
            }

            if (highlight) {
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.strokeRect(highlight.x * tileSize, highlight.z * tileSize, tileSize, tileSize);
            }
        }

        function randomSeed() {
            document.getElementById('seed').value = Math.floor(Math.random() * 1000000);
            generateInstant();
        }

        function generateInstant() {
            stopAnimation();
            const width = parseInt(document.getElementById('width').value);
            const height = parseInt(document.getElementById('height').value);
            const seed = parseInt(document.getElementById('seed').value);
            const tileSize = parseInt(document.getElementById('tileSize').value);

            const config = getConfig();
            const town = new Town(width, height);
            const rng = seededRandom(seed);

            town.generateCliffs(rng, config, null);
            town.generateRivers(rng, config, null);

            appState.town = town;
            renderTown(town, tileSize);
            document.getElementById('debugInfo').innerText = "Generated successfully.";

            // disable timeline
            document.getElementById('timeline').disabled = true;
            document.getElementById('btnPause').disabled = true;
            document.getElementById('btnStep').disabled = true;
        }

        function startDebug() {
            stopAnimation();
            const width = parseInt(document.getElementById('width').value);
            const height = parseInt(document.getElementById('height').value);
            const seed = parseInt(document.getElementById('seed').value);
            const tileSize = parseInt(document.getElementById('tileSize').value);

            const config = getConfig();
            const town = new Town(width, height);
            const rng = seededRandom(seed);

            appState.steps = [];
            town.generateCliffs(rng, config, appState.steps);
            town.generateRivers(rng, config, appState.steps);

            // Reset town for playback
            appState.town = new Town(width, height);
            appState.currentStepIndex = 0;

            const timeline = document.getElementById('timeline');
            timeline.disabled = false;
            timeline.max = appState.steps.length;
            timeline.value = 0;

            document.getElementById('btnPause').disabled = false;
            document.getElementById('btnStep').disabled = false;

            renderTown(appState.town, tileSize);

            // Auto start
            appState.isPlaying = true;
            document.getElementById('btnPause').innerText = "Pause";
            runLoop();
        }

        function runLoop() {
            const speed = parseInt(document.getElementById('animSpeed').value);
            appState.interval = setInterval(() => {
                if (appState.currentStepIndex >= appState.steps.length) {
                    appState.isPlaying = false;
                    document.getElementById('btnPause').innerText = "Replay";
                    clearInterval(appState.interval);
                    return;
                }
                step();
            }, speed);
        }

        function stopAnimation() {
            if (appState.interval) clearInterval(appState.interval);
            appState.isPlaying = false;
        }

        function togglePause() {
            if (appState.isPlaying) {
                stopAnimation();
                document.getElementById('btnPause').innerText = "Resume";
            } else {
                if (appState.currentStepIndex >= appState.steps.length) {
                    // Reset to 0 if finished
                    appState.currentStepIndex = 0;
                    appState.town = new Town(appState.town.width, appState.town.height);
                }
                appState.isPlaying = true;
                document.getElementById('btnPause').innerText = "Pause";
                runLoop();
            }
        }

        function step() {
            if (appState.currentStepIndex >= appState.steps.length) return;

            const s = appState.steps[appState.currentStepIndex];
            const t = appState.town.getTile(s.x, s.z);

            if (s.type === 'elev') t.elevation = s.val;
            if (s.type === 'cliff') t.type = s.val;
            if (s.type === 'water') t.type = s.val;

            appState.currentStepIndex++;
            document.getElementById('timeline').value = appState.currentStepIndex;
            document.getElementById('stepDisplay').innerText = `${appState.currentStepIndex} / ${appState.steps.length}`;

            const tileSize = parseInt(document.getElementById('tileSize').value);

            // Optimization: Only full render every N steps if speed is fast, 
            // otherwise just draw the tile changed? 
            // For simplicity in this demo, we re-render full.
            renderTown(appState.town, tileSize, { x: s.x, z: s.z });
            document.getElementById('debugInfo').innerText = s.msg;
        }

        function scrub(val) {
            stopAnimation();
            document.getElementById('btnPause').innerText = "Resume";

            const target = parseInt(val);
            // Rebuild town state from 0 to target
            // (Inefficient but robust for debug correctness)
            const width = parseInt(document.getElementById('width').value);
            const height = parseInt(document.getElementById('height').value);

            appState.town = new Town(width, height);

            for (let i = 0; i < target; i++) {
                const s = appState.steps[i];
                const t = appState.town.getTile(s.x, s.z);
                if (s.type === 'elev') t.elevation = s.val;
                if (s.type === 'cliff') t.type = s.val;
                if (s.type === 'water') t.type = s.val;
            }

            appState.currentStepIndex = target;
            const tileSize = parseInt(document.getElementById('tileSize').value);
            renderTown(appState.town, tileSize);
            document.getElementById('stepDisplay').innerText = `${target} / ${appState.steps.length}`;
        }

        // Initial load
        generateInstant();

    </script>
</body>

</html>